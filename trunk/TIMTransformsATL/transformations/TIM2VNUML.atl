module TIM2VNUML; -- Module Template
create OUT : XML from IN : TIMSmall;

helper def: TranslateMask(m : String ) : String =
	-- FIXME: only works by the moment for "8-bit dotted"
	if (m = '255.255.255.0') then
		'24'
	else
		if (m = '255.255.0.0') then
			'16'
		else
			if (m = '255.0.0.0') then
				'8'
			else
				'0'
			endif
		endif
	endif
	;

helper def: vmInterfaces(vm : TIMSmall!CIM_ComputerSystem) : Sequence(TIMSmall!CIM_IPProtocolEndpoint) =
	TIMSmall!CIM_HostedAccessPoint.allInstances()->iterate(e; res : Sequence(TIMSmall!CIM_IPProtocolEndpoint) = Sequence {} | 
		if e.Antecedent = vm		
		then
			res->including(e.Dependent)
		else
			res
		endif
	);

helper def: vmRoutes(vm : TIMSmall!CIM_ComputerSystem) : Sequence(TIMSmall!TIM_NextHopAddressedIPRoute) =
	TIMSmall!CIM_HostedRoute.allInstances()->iterate(e; res : Sequence(TIMSmall!TIM_NextHopAddressedIPRoute) = Sequence {} | 
		if e.Antecedent = vm		
		then
			res->including(e.Dependent)
		else
			res
		endif
	);

helper def: vmForwarding(vm : TIMSmall!CIM_ComputerSystem) : Sequence(TIMSmall!CIM_ForwardingService) =
	TIMSmall!CIM_HostedService.allInstances()->iterate(e; res : Sequence(TIMSmall!CIM_ForwardingService) = Sequence {} | 
		if e.Antecedent = vm		
		then
			res->including(e.Dependent)
		else
			res
		endif
	);
	
helper def: intfIpv4(intf : TIMSmall!CIM_IPProtocolEndpoint) : Sequence(TIMSmall!CIM_StaticIPAssignmentSettingData) =
	-- We have to use ->first() in the ManagemedElement because it is defined as "to-many" reference in the
	-- TIM metamodel
	TIMSmall!CIM_ElementSettingData.allInstances()->iterate(e; res : Sequence(TIMSmall!CIM_StaticIPAssignmentSettingData) = Sequence {} | 
		if e.ManagedElement->first() = intf
		then
			if e.SettingData->first().oclIsTypeOf(TIMSmall!CIM_StaticIPAssignmentSettingData)
			then
				res->including(e.SettingData->first())
			else
				res
			endif
		else
			res
		endif	
	);

helper def: intfIpv6(intf : TIMSmall!CIM_IPProtocolEndpoint) : Sequence(TIMSmall!TIM_StaticIPv6AssignmentSettingData) =
	-- We have to use ->first() in the ManagemedElement because it is defined as "to-many" reference in the
	-- TIM metamodel
	TIMSmall!CIM_ElementSettingData.allInstances()->iterate(e; res : Sequence(TIMSmall!TIM_StaticIPv6AssignmentSettingData) = Sequence {} | 
		if e.ManagedElement->first() = intf
		then
			if e.SettingData->first().oclIsTypeOf(TIMSmall!TIM_StaticIPv6AssignmentSettingData)
			then
				res->including(e.SettingData->first())
			else
				res
			endif
		else
			res
		endif	
	);

helper def: netNameForIntf(intf : TIMSmall!CIM_IPProtocolEndpoint) : String =
	if TIMSmall!TIM_MemberOfLink.allInstances()->exists(e | e.Member->first() = intf)
	then
		TIMSmall!TIM_MemberOfLink.allInstances()->select(e | e.Member->first() = intf)->first().Collection->first().InstanceID
	else
		'lo'
	endif
	;

rule Root {
	from 
		i: TIMSmall!TIM_TestbedScenario
	to
		root: XML!Root (
			name <- 'vnuml',
			children <- global
		),
		global: XML!Element (
			name <- 'global',
			-- We assume that each input model containts exactly one testbed scenario, so we don't need
			-- to navigate through the CIM_HostedCollection and CIM_SystemComponent associations: we
			-- just include all the TIM_LinkConnectivityCollection and CIM_ComputerSystem instances
			children <- Sequence{version, simulationName, automac, vmMgmt, vmDefaults,
					TIMSmall!TIM_LinkConnectivityCollection.allInstances()->collect (e | thisModule.resolveTemp(e,'net')),
					TIMSmall!CIM_ComputerSystem.allInstances()->collect (e | thisModule.resolveTemp(e,'vm')) }
		),
		version: XML!Element (
			name <- 'version',
			children <- version_Text
		),
		version_Text: XML!TextNode (
			-- FIXME: unhardwire
			value <- '1.8'
		),
		simulationName: XML!Element (
			name <- 'simulation_name',
			children <- simulationName_Text
		),
		simulationName_Text: XML!TextNode (
			value <- i.Name
		),
		automac: XML!Element (
			name <- 'automac'
		),
		vmMgmt: XML!Element (
			name <- 'vm_mgmt',
			children <- vmMgmt_attType
		),
		vmMgmt_attType: XML!Attribute (
			name <- 'type',
			value <- 'none'
		),
		vmDefaults: XML!Element (
			name <- 'vm_defaults',
			children <- Sequence{vmDefaults_attExecMode, filesystem, kernel, console}
		),
		vmDefaults_attExecMode: XML!Attribute (
			name <- 'exec_mode',
			value <- 'mconsole'
		),
		filesystem: XML!Element (
			name <- 'filesystem',
			children <- filesystem_attType,
			children <- filesystem_Text
		),
		filesystem_attType: XML!Attribute (
			name <- 'type',
			-- FIXME: unhardwire
			value <- 'cow'
		),
		filesystem_Text: XML!TextNode (
			-- FIXME: unhardwire
			value <- '/usr/share/vnuml/filesystems/root_fs_tutorial'
		),
		kernel: XML!Element (
			name <- 'kernel',
			children <- kernel_Text
		),
		kernel_Text: XML!TextNode (
			-- FIXME: unhardwire
			value <- '/usr/share/vnuml/kernels/linux'
		),
		console: XML!Element (
			name <- 'console',
			children <- console_attId,
			children <- console_Text
		),
		console_attId: XML!Attribute (
			name <- 'id',
			value <- '0'
		),
		console_Text: XML!TextNode (
			-- FIXME: unhardwire
			value <- 'xterm'
		)
}

rule Net {
	from
		i: TIMSmall!TIM_LinkConnectivityCollection
	to
		net: XML!Element (
			name <- 'net',
			children <- net_attName,
			children <- net_attMode
		),
		net_attName: XML!Attribute (
			name <- 'name',
			value <- i.InstanceID
		),
		net_attMode: XML!Attribute (
			name <- 'mode',
			value <- 'uml_switch'
		)
}

rule Vm {
	from
		i: TIMSmall!CIM_ComputerSystem
	to
		vm: XML!Element (
			name <- 'vm',
			children <- Sequence{vm_attName,
					thisModule.vmInterfaces(i)->collect (e | thisModule.resolveTemp(e,'intf')),
					thisModule.vmRoutes(i)->collect (e | thisModule.resolveTemp(e,'route')),
					thisModule.vmForwarding(i)->collect (e | thisModule.resolveTemp(e,'forwarding')) }
		),
		vm_attName: XML!Attribute (
			name <- 'name',
			value <- i.Name
		)
}

rule Intf {
	from
		i: TIMSmall!CIM_IPProtocolEndpoint
	to
		intf: XML!Element (
			name <- 'if',
			children <- Sequence{intf_attId, intf_attNet,
					thisModule.intfIpv4(i)->collect (e | thisModule.resolveTemp(e,'ipv4')),
					thisModule.intfIpv6(i)->collect (e | thisModule.resolveTemp(e,'ipv6')) }

		),
		intf_attId: XML!Attribute (
			name <- 'id',
			value <- 'TODO'
		),
		intf_attNet: XML!Attribute (
			name <- 'net',
			value <- thisModule.netNameForIntf(i)
		)
}

rule Ipv4 {
	from
		i: TIMSmall!CIM_StaticIPAssignmentSettingData
	to
		ipv4: XML!Element (
			name <- 'ipv4',
			children <- ipv4_attMask,
			children <- ipv4_Text
		),
		ipv4_attMask: XML!Attribute (
			name <- 'mask',
			value <- i.SubnetMask
		),
		ipv4_Text: XML!TextNode (
			value <- i.IPv4Address
		)
}

rule Ipv6 {
	from
		i: TIMSmall!TIM_StaticIPv6AssignmentSettingData
	to
		ipv6: XML!Element (
			name <- 'ipv6',
			children <- ipv6_attMask,
			children <- ipv6_Text
		),
		ipv6_attMask: XML!Attribute (
			name <- 'mask',
			value <- '/' + i.PrefixLength.toString()
		),
		ipv6_Text: XML!TextNode (
			value <- i.IPv6Address
		)
}

rule Route {
	from
		i: TIMSmall!TIM_NextHopAddressedIPRoute
	to
		route: XML!Element (
			name <- 'route',
			children <- route_attGw,
			children <- route_attType,
			children <- route_Text
		),
		route_attGw: XML!Attribute (
			name <- 'gw',
			value <- i.NextHopAddress
		),
		route_attType: XML!Attribute (
			name <- 'type',
			value <- (if i.AddressType = '1' then 'ipv4' else 'ipv6' endif)
		),
		route_Text: XML!TextNode (
			value <- (if i.AddressType = '1' then 
					    -- IPv4
						i.DestinationAddress + '/' + thisModule.TranslateMask(i.DestinationMask)
					  else
					    -- IPv6
					  	i.DestinationAddress + '/' + i.PrefixLength
					  endif)
		)
}

rule Forwarding {
	from
		i: TIMSmall!CIM_ForwardingService 
	to
		forwarding: XML!Element (
			name <- 'forwarding',
			children <- forwarding_attType
		),
		forwarding_attType: XML!Attribute (
			name <- 'type',
			value <- (if i.ProtocolType = '2' then
						'ipv4'
					  else
					  	if i.ProtocolType = '3' then
							'ipv6'
						else
							-- i.Protocol = '4'
							'ip'
						endif
				      endif )
		)
}